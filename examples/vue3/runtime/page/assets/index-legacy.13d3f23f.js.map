{"version":3,"file":"index-legacy.13d3f23f.js","sources":["../../../../../../packages/ui/src/cline/src/index.vue"],"sourcesContent":["<template>\n  <div class=\"t-inline-block magic-ui-echart-module\" ref=\"refContainer\" :style=\"style\" />\n</template>\n\n<script lang=\"ts\" setup>\nimport { onMounted, Ref, ref, shallowRef, watch } from 'vue';\nimport * as echarts from 'echarts';\n\nimport { legendInitOption, seriesLabelOption } from '../../commonConfig';\nimport { MCLine } from '../../types';\nimport useApp from '../../useApp';\nimport useEcharts from '../../useEcharts';\nimport useStyle from '../../useStyle';\nimport { getShowMaxLabelOption, setLineBarChartData, setLineBarCommonOption, shouldUpdateCreator } from '../../util';\nconst props = defineProps<{\n  config: MCLine;\n  // model: Object;\n}>();\n\nuseApp(props);\nconst refContainer = ref<HTMLElement | null>(null);\nconst refCharts = shallowRef<any>();\n\ntype SeriesDataType = {\n  type: 'line';\n  name: string;\n  color: string;\n  data: Array<string | number>;\n  gradient: string[];\n  smooth: boolean;\n  areaStyle: ReturnType<typeof getAreaStyle>;\n  symbol: MCLine['markSymbol'];\n  label?: Object;\n  symbolSize: number;\n};\n\nlet xAxisData = [];\nconst getChartData = () => {\n  const { dataList, colList } = props.config.dataSourceModel;\n  const result = dataList!.reduce(\n    (\n      ret: {\n        xAxisData: string[];\n        seriesData: SeriesDataType[];\n      },\n      cur: Array<string | number>,\n    ) => {\n      const { xAxisData, seriesData } = ret;\n      cur.forEach((itm: any, idx: number) => {\n        if (idx === 0) {\n          xAxisData.push(itm as string);\n        } else {\n          const tableIdx = idx - 1;\n          seriesData[tableIdx] = seriesData[tableIdx] || { data: [] };\n\n          const seriesDataItem = seriesData[tableIdx];\n          seriesDataItem.type = 'line';\n          seriesDataItem.data.push(itm);\n\n          const item = colList?.[idx] as any;\n          seriesDataItem.color = item.color;\n          seriesDataItem.name = item.label;\n          seriesDataItem.label = seriesLabelOption(props.config);\n          seriesDataItem.gradient = item.gradient;\n          seriesDataItem.smooth = props.config.smooth!;\n          seriesDataItem.areaStyle = getAreaStyle(\n            props.config.hasAreaStyle!,\n            item.gradient,\n            props.config.areaStyleOpacity,\n          );\n          seriesDataItem.symbol = props.config.markSymbol;\n          seriesDataItem.symbolSize = props.config.symbolSize;\n        }\n      });\n      return ret;\n    },\n    { xAxisData: [], seriesData: [] },\n  );\n  xAxisData = result.xAxisData;\n  return {\n    xAxisData: result.xAxisData,\n    series: result.seriesData,\n    legendData: colList?.slice(1).map((item) => item.label),\n  };\n};\nconst getAreaStyle = (hasAreaStyle: boolean, gradient: string[], areaStyleOpacity?: boolean) =>\n  hasAreaStyle\n    ? {\n        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [\n          {\n            offset: 0,\n            color: gradient[0],\n          },\n          {\n            offset: 1,\n            color: gradient[areaStyleOpacity ? 1 : 0],\n          },\n        ]),\n      }\n    : undefined;\n\nonMounted(() => {\n  const { config } = props;\n  const option = {\n    legend: [\n      {\n        ...legendInitOption(config),\n        data: [],\n      },\n    ],\n    grid: {\n      top: config.gridTop,\n      right: config.gridRight,\n      bottom: config.gridBottom,\n      left: config.gridLeft,\n      containLabel: true,\n    },\n    tooltip: [\n      {\n        show: config.tooltip,\n        trigger: 'axis',\n        axisPointer: {\n          type: 'cross',\n        },\n        confine: true,\n      },\n    ],\n    xAxis: [\n      {\n        type: 'category',\n        nameGap: 5,\n        data: [],\n        boundaryGap: false,\n        axisLabel: {\n          textStyle: {\n            color: config.xAxisFontSizeColor,\n          },\n          fontSize: config.xAxisFontSize,\n        } as any,\n        axisLine: {\n          lineStyle: {\n            color: config.xAxisAxisLineColor,\n          },\n        },\n      },\n    ],\n    yAxis: [\n      {\n        type: 'value',\n        nameGap: 5,\n        axisLabel: {\n          textStyle: {\n            color: config.yAxisFontSizeColor,\n          },\n          fontSize: config.yAxisFontSize,\n        } as any,\n        splitLine: {\n          lineStyle: {\n            type: config.splitLineType,\n            color: config.splitLineColor,\n          },\n        },\n      },\n    ],\n    series: [],\n  } as any;\n  refCharts.value = useEcharts(option, refContainer as Ref<HTMLElement>).value;\n\n  watch(\n    () => props.config,\n    (newVal, oldVal: any = {}) => {\n      const option = refCharts.value?.getOption();\n      const shouldUpdate = shouldUpdateCreator(newVal, oldVal);\n\n      setLineBarCommonOption(shouldUpdate, option, newVal, { suffixFormat: true });\n\n      if (shouldUpdate('smooth')) {\n        option.series.forEach((item: echarts.EChartsOption) => {\n          item.smooth = newVal.smooth;\n        });\n      }\n      if (shouldUpdate('hasAreaStyle')) {\n        const colList = newVal.dataSourceModel?.colList;\n        option.series = option.series.map((item: any, index: number) => {\n          item.areaStyle = getAreaStyle(\n            newVal.hasAreaStyle as boolean,\n            (colList?.[index + 1] as any).gradient,\n            newVal.getAreaStyle,\n          );\n          return item;\n        });\n      }\n      if (shouldUpdate('xAxisHeadTailTextFormat', 'xAxisFontSize')) {\n        const dataLenIndex = xAxisData.length - 1;\n        const shouldFormat = newVal.xAxisHeadTailTextFormat && dataLenIndex > 0;\n        Object.assign(\n          option.xAxis[0].axisLabel,\n          shouldFormat\n            ? getShowMaxLabelOption(dataLenIndex, newVal.xAxisFontSize)\n            : { formatter: undefined, rich: undefined },\n        );\n      }\n\n      setLineBarChartData(option, getChartData);\n      refCharts.value.setOption(option, true);\n    },\n    {\n      immediate: true,\n    },\n  );\n});\n\nconst style = useStyle(props, refCharts);\n</script>\n<style lang=\"scss\" scoped>\n.t-inline-block {\n  display: inline-block;\n}\n</style>\n"],"names":["useApp","props","refContainer","Vue","refCharts","shallowRef","xAxisData","getChartData","dataList","colList","config","dataSourceModel","result","reduce","ret","cur","xAxisData2","seriesData","forEach","itm","idx","push","tableIdx","data","seriesDataItem","type","item","color","name","label","seriesLabelOption","gradient","smooth","areaStyle","getAreaStyle","hasAreaStyle","areaStyleOpacity","symbol","markSymbol","symbolSize","series","legendData","slice","map","echarts.graphic.LinearGradient","offset","onMounted","option","legend","legendInitOption","grid","top","gridTop","right","gridRight","bottom","gridBottom","left","gridLeft","containLabel","tooltip","show","trigger","axisPointer","confine","xAxis","nameGap","boundaryGap","axisLabel","textStyle","xAxisFontSizeColor","fontSize","xAxisFontSize","axisLine","lineStyle","xAxisAxisLineColor","yAxis","yAxisFontSizeColor","yAxisFontSize","splitLine","splitLineType","splitLineColor","value","useEcharts","watch","newVal","oldVal","option2","getOption","shouldUpdate","shouldUpdateCreator","setLineBarCommonOption","suffixFormat","index","dataLenIndex","length","shouldFormat","xAxisHeadTailTextFormat","Object","assign","getShowMaxLabelOption","formatter","rich","setLineBarChartData","setOption","immediate","style","useStyle"],"mappings":"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"}