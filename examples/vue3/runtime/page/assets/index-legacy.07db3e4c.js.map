{"version":3,"file":"index-legacy.07db3e4c.js","sources":["../../../../../../packages/ui/src/clinebar/src/index.vue"],"sourcesContent":["<template>\n  <div class=\"t-inline-block magic-ui-echart-module\" ref=\"refContainer\" :style=\"style\" />\n</template>\n\n<script lang=\"ts\" setup>\nimport { onMounted, Ref, ref, shallowRef, watch } from 'vue';\nimport * as echarts from 'echarts';\n\nimport { legendInitOption, seriesLabelOption } from '../../commonConfig';\nimport { MCLineBar } from '../../types';\nimport useApp from '../../useApp';\nimport useEcharts from '../../useEcharts';\nimport useStyle from '../../useStyle';\nimport { getBarItemStyle, setLineBarChartData, setLineBarCommonOption, shouldUpdateCreator } from '../../util';\nconst props = defineProps<{\n  config: MCLineBar;\n  // model: Object;\n}>();\n\nuseApp(props);\nconst refContainer = ref<HTMLElement | null>(null);\nconst refCharts = shallowRef<any>();\n\ntype SeriesDataType = {\n  type: MCLineBar['type'];\n  name: string;\n  color?: string;\n  data: Array<string | number> | { value: any; [prop: string]: any };\n  gradient: string[];\n  smooth?: boolean;\n  symbol?: string;\n  yAxisIndex?: number;\n  tooltip: Record<string, any>;\n  areaStyle?: Record<string, any>;\n  zlevel?: number;\n  symbolSize?: number;\n  label?: Object;\n};\n\nconst getChartData = () => {\n  const newVal = props.config;\n  const { dataList, colList } = props.config.dataSourceModel!;\n  const { smooth, hasAreaStyle } = newVal;\n  const barZlevel = hasAreaStyle && newVal.lineChartLowestLevel ? 1 : 0;\n  const borderRadius = [newVal.borderRadiusLT, newVal.borderRadiusRT, newVal.borderRadiusRB, newVal.borderRadiusLB].map(\n    (item) => Number(item || 0),\n  );\n  let whichYAxisIndex = ''\n  const result = dataList!.reduce(\n    (\n      ret: {\n        xAxisData: string[];\n        seriesData: SeriesDataType[];\n      },\n      cur: Array<string | number>,\n    ) => {\n      const { xAxisData, seriesData } = ret;\n      cur.forEach((itm: any, idx: number) => {\n        if (idx === 0) {\n          xAxisData.push(itm as string);\n        } else {\n          const tableIdx = idx - 1;\n          seriesData[tableIdx] = seriesData[tableIdx] || { data: [] };\n\n          const seriesDataItem = seriesData[tableIdx];\n\n          const item = colList?.[idx] as any;\n          const { type } = item;\n          const isLine = type === 'line';\n          seriesDataItem.type = type;\n          seriesDataItem.name = item.label;\n          seriesDataItem.color = item.color;\n          seriesDataItem.tooltip = {\n            valueFormatter(value: any) {\n              return value + item.suffix || '';\n            },\n          };\n          if (!whichYAxisIndex) {\n            whichYAxisIndex = type;\n          }\n          if (whichYAxisIndex !== type) {\n            seriesDataItem.yAxisIndex = 1;\n          }\n          if (isLine) {\n            seriesDataItem.label = seriesLabelOption(newVal);\n            seriesDataItem.data.push(itm);\n            seriesDataItem.smooth = smooth;\n            seriesDataItem.areaStyle = getAreaStyle(newVal.hasAreaStyle!, item.gradient, newVal.areaStyleOpacity);\n            seriesDataItem.symbol = newVal.markSymbol;\n            seriesDataItem.symbolSize = newVal.symbolSize;\n          } else {\n            seriesDataItem.data.push({\n              value: itm,\n              itemStyle: getBarItemStyle(itm, { borderRadius }),\n              label: seriesLabelOption(newVal, {\n                isBar: true,\n                value: itm,\n              }),\n            });\n            seriesDataItem.zlevel = barZlevel;\n          }\n        }\n      });\n      return ret;\n    },\n    { xAxisData: [], seriesData: [] },\n  );\n  return {\n    xAxisData: result.xAxisData,\n    series: result.seriesData,\n    legendData: colList?.slice(1).map((item) => item.label),\n  };\n};\nconst getAreaStyle = (hasAreaStyle: boolean, gradient: string[], areaStyleOpacity?: boolean) =>\n  hasAreaStyle\n    ? {\n        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [\n          {\n            offset: 0,\n            color: gradient[0],\n          },\n          {\n            offset: 1,\n            color: gradient[areaStyleOpacity ? 1 : 0],\n          },\n        ]),\n      }\n    : undefined;\nonMounted(() => {\n  const { config } = props;\n  const option = {\n    legend: [\n      {\n        ...legendInitOption(config),\n        data: [],\n      },\n    ],\n    grid: {\n      top: config.gridTop,\n      right: config.gridRight,\n      bottom: config.gridBottom,\n      left: config.gridLeft,\n      containLabel: true,\n    },\n    tooltip: [\n      {\n        show: config.tooltip,\n        trigger: 'axis',\n        axisPointer: {\n          type: 'cross',\n        },\n        confine: true,\n      },\n    ],\n    xAxis: [\n      {\n        type: 'category',\n        nameGap: 5,\n        data: [],\n        axisLabel: {\n          textStyle: {\n            color: config.xAxisFontSizeColor,\n          },\n          fontSize: config.xAxisFontSize,\n        } as any,\n        axisLine: {\n          lineStyle: {\n            color: config.xAxisAxisLineColor,\n          },\n        },\n      },\n    ],\n    yAxis: [\n      {\n        type: 'value',\n        nameGap: 5,\n        axisLabel: {\n          textStyle: {\n            color: config.yAxisFontSizeColor,\n          },\n          fontSize: config.yAxisFontSize,\n        } as any,\n        splitLine: {\n          lineStyle: {\n            type: config.splitLineType,\n            color: config.splitLineColor,\n          },\n        },\n      },\n      {\n        type: 'value',\n        nameGap: 5,\n        axisLabel: {\n          textStyle: {\n            color: config.yAxisFontSizeColor,\n          },\n          fontSize: config.yAxisFontSize,\n        } as any,\n        splitLine: {\n          lineStyle: {\n            type: config.splitLineType,\n            color: config.splitLineColor,\n          },\n        },\n      },\n    ],\n    series: [],\n  } as any;\n  refCharts.value = useEcharts(option, refContainer as Ref<HTMLElement>).value;\n  watch(\n    () => props.config,\n    (newVal, oldVal: any = {}) => {\n      const option = refCharts.value?.getOption();\n      const shouldUpdate = shouldUpdateCreator(newVal, oldVal);\n\n      setLineBarCommonOption(shouldUpdate, option, newVal, { isMixin: true });\n      if (shouldUpdate('yAxisLeftSuffix', 'yAxisRightSuffix', 'yAxisShowZero')) {\n        const suffixs = [newVal.yAxisLeftSuffix, newVal.yAxisRightSuffix];\n        option.yAxis.forEach((item: any, index: number) => {\n          item.axisLabel.formatter = (value: string) => (!newVal.yAxisShowZero && !value ? '' : value + suffixs[index]);\n        });\n      }\n      if (shouldUpdate('yAxisLeftName', 'yAxisRightName')) {\n        const names = [newVal.yAxisLeftName, newVal.yAxisRightName];\n        option.yAxis.forEach((item: any, index: number) => {\n          item.name = names[index];\n        });\n      }\n\n      setLineBarChartData(option, getChartData);\n      refCharts.value.setOption(option, true);\n    },\n    {\n      immediate: true,\n    },\n  );\n});\n\nconst style = useStyle(props, refCharts);\n</script>\n<style lang=\"scss\" scoped>\n.t-inline-block {\n  display: inline-block;\n}\n</style>\n"],"names":["useApp","props","refContainer","Vue","refCharts","shallowRef","getChartData","newVal","config","dataList","colList","dataSourceModel","smooth","hasAreaStyle","barZlevel","lineChartLowestLevel","borderRadius","borderRadiusLT","borderRadiusRT","borderRadiusRB","borderRadiusLB","map","item","Number","whichYAxisIndex","result","reduce","ret","cur","xAxisData","seriesData","forEach","itm","idx","push","tableIdx","data","seriesDataItem","type","isLine","name","label","color","tooltip","valueFormatter","value","suffix","yAxisIndex","seriesLabelOption","areaStyle","getAreaStyle","gradient","areaStyleOpacity","symbol","markSymbol","symbolSize","itemStyle","getBarItemStyle","isBar","zlevel","series","legendData","slice","echarts.graphic.LinearGradient","offset","onMounted","option","legend","legendInitOption","grid","top","gridTop","right","gridRight","bottom","gridBottom","left","gridLeft","containLabel","show","trigger","axisPointer","confine","xAxis","nameGap","axisLabel","textStyle","xAxisFontSizeColor","fontSize","xAxisFontSize","axisLine","lineStyle","xAxisAxisLineColor","yAxis","yAxisFontSizeColor","yAxisFontSize","splitLine","splitLineType","splitLineColor","useEcharts","watch","oldVal","option2","getOption","shouldUpdate","shouldUpdateCreator","setLineBarCommonOption","isMixin","suffixs","yAxisLeftSuffix","yAxisRightSuffix","index","formatter","yAxisShowZero","names","yAxisLeftName","yAxisRightName","setLineBarChartData","setOption","immediate","style","useStyle"],"mappings":"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"}